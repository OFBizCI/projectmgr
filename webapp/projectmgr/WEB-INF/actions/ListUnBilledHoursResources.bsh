/*
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
  
import java.util.*;
import java.lang.*;
import org.ofbiz.entity.*;
import org.ofbiz.entity.condition.*;
import org.ofbiz.entity.util.EntityUtil;
import org.ofbiz.base.util.*;
import javolution.util.FastMap;
import javolution.util.FastList;

delegator = parameters.get("delegator");

// get the projects the client has the CLIENT_BILLING role.
tasks = EntityUtil.filterByDate(delegator.findByAnd("ProjectPartyAndPhaseAndTask", UtilMisc.toMap("partyId", parameters.get("partyId"), "roleTypeId", "CLIENT_BILLING")));

if (!UtilValidate.isEmpty(tasks)) {
    List unBilledList = FastList.newInstance();
    //list all the tasks of he projects and check for registered and approved and unbilled hours
    taskIterator = tasks.iterator();
    while (taskIterator.hasNext()) {
        task = taskIterator.next();
        timeEntries = task.getRelated("TimeEntry");
        if (!UtilValidate.isEmpty(timeEntries)) {
            teIterator = timeEntries.iterator();
            while (teIterator.hasNext()) {
                timeEntry = teIterator.next();
                // check if entry already invoiced
                if (timeEntry.getString("invoiceId") == null) {
                    timesheet = timeEntry.getRelatedOne("Timesheet");
                    // check the role of his part, if party is a provider
                    exprs = UtilMisc.toList(
                                new EntityExpr("workEffortId", EntityOperator.EQUALS, timeEntry.getString("workEffortId")),
                                new EntityExpr("partyId", EntityOperator.EQUALS, timeEntry.getString("partyId")),
                                new EntityExpr("roleTypeId", EntityOperator.LIKE, "PROVIDER_%"));
                    ecl = new EntityConditionList(exprs, EntityOperator.AND);
                    providerRoles = EntityUtil.filterByDate(delegator.findList("WorkEffortPartyAssignment", ecl, null, null, null, false));
                    if (!UtilValidate.isEmpty(providerRoles)) {
                        rates = EntityUtil.filterByDate(delegator.findByAnd("PartyRate", 
                            UtilMisc.toMap("partyId", timesheet.getString("partyId"), "rateTypeId", timeEntry.getString("rateTypeId"))));
                        if (UtilValidate.isEmpty(rates)) {
                            Debug.logError("TimeEntry has a number of hours, but no rateTypeId for this party was found: Timesheet: " + timesheet.getString("timesheetId"), "billingByCient");
                        } else {
                            rate = rates.get(0); 
                            unBilledMap = UtilMisc.toMap("projectId", task.getString("projectId"),
                                "projectName", task.getString("projectName"),                             
                                "phaseName", task.getString("phaseName"),                             
                                "taskName", task.getString("workEffortName"),                             
                                "taskId", task.getString("workEffortId"),
                                "hours", timeEntry.get("hours"));
                            unBilledMap.put("rate", rate.get("rate"));
                            unBilledMap.put("total", rate.get("rate") * timeEntry.get("hours"));
                            unBilledList.add(unBilledMap);
                        }                             
                    }
                }
            }
        }
    }
    context.put("unBilledList", unBilledList);
}

